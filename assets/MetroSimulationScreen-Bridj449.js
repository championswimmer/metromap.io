import{C as E,L as k,F as w,G as C,M as V,s as N,_ as A,D as v,c as O,a as R,b as _,d as M,e as X,f as z,T as H,g as F}from"./index-BUSpScVp.js";function W(b,t=0,n=1){return{id:`train-${Date.now()}-${Math.random().toString(36).substr(2,5)}`,lineId:b,currentStationIdx:t,targetStationIdx:t+1,progress:0,direction:1,speed:n,currentSegment:null,totalLength:0}}const u=16,P=u*.5,G=16777215,$=0,U=2,q=4,Y=4,Z=8,K=300*1e3,j=600*1e3,J=1200*1e3,Q=3600*1e3;class et extends E{static assetBundles=["main"];titleLabel;clockLabel;stopButton;speed1xButton;speed2xButton;speed4xButton;speed12xButton;mapRenderer;mapContainer;mapBackground;linesLayer;trainsLayer;stationsLayer;gameState;isRunning=!1;currentSpeed="1x";lastUpdateTime=0;constructor(){super(),this.titleLabel=new k({text:"Metro Simulation",style:{fontSize:36,fill:16777215}}),this.addChild(this.titleLabel),this.clockLabel=new k({text:this.formatDateTime(new Date("2025-01-01T08:00:00")),style:{fontSize:24,fill:8965375,fontFamily:"monospace"}}),this.addChild(this.clockLabel),this.stopButton=new w({text:"Stop Simulation",width:160,height:50,fontSize:18,backgroundColor:15158332}),this.stopButton.onPress.connect(()=>this.stopSimulation()),this.addChild(this.stopButton),this.speed1xButton=new w({text:"1x",width:60,height:50,fontSize:18,backgroundColor:4886754}),this.speed1xButton.onPress.connect(()=>this.setSpeed("1x")),this.addChild(this.speed1xButton),this.speed2xButton=new w({text:"2x",width:60,height:50,fontSize:18,backgroundColor:5592405}),this.speed2xButton.onPress.connect(()=>this.setSpeed("2x")),this.addChild(this.speed2xButton),this.speed4xButton=new w({text:"4x",width:60,height:50,fontSize:18,backgroundColor:5592405}),this.speed4xButton.onPress.connect(()=>this.setSpeed("4x")),this.addChild(this.speed4xButton),this.speed12xButton=new w({text:"12x",width:60,height:50,fontSize:18,backgroundColor:5592405}),this.speed12xButton.onPress.connect(()=>this.setSpeed("12x")),this.addChild(this.speed12xButton),this.mapContainer=new E,this.addChild(this.mapContainer),this.mapBackground=new C,this.mapContainer.addChild(this.mapBackground),this.mapRenderer=new V,this.mapContainer.addChild(this.mapRenderer),this.linesLayer=new C,this.mapContainer.addChild(this.linesLayer),this.trainsLayer=new C,this.mapContainer.addChild(this.trainsLayer),this.stationsLayer=new C,this.mapContainer.addChild(this.stationsLayer)}formatDateTime(t){if(!t||isNaN(t.getTime())){const c=new Date("2025-01-01T08:00:00");return this.formatDateTime(c)}const n=t.getDate().toString().padStart(2,"0"),e=(t.getMonth()+1).toString().padStart(2,"0"),s=t.getFullYear(),i=t.getHours().toString().padStart(2,"0"),r=t.getMinutes().toString().padStart(2,"0");return`${n}/${e}/${s} ${i}:${r}`}setSpeed(t){this.currentSpeed=t,t==="1x"?(this.speed1xButton.alpha=1,this.speed1xButton.defaultView.tint=4886754,this.speed2xButton.alpha=.7,this.speed2xButton.defaultView.tint=8947848,this.speed4xButton.alpha=.7,this.speed4xButton.defaultView.tint=8947848,this.speed12xButton.alpha=.7,this.speed12xButton.defaultView.tint=8947848):t==="2x"?(this.speed1xButton.alpha=.7,this.speed1xButton.defaultView.tint=8947848,this.speed2xButton.alpha=1,this.speed2xButton.defaultView.tint=4886754,this.speed4xButton.alpha=.7,this.speed4xButton.defaultView.tint=8947848,this.speed12xButton.alpha=.7,this.speed12xButton.defaultView.tint=8947848):t==="4x"?(this.speed1xButton.alpha=.7,this.speed1xButton.defaultView.tint=8947848,this.speed2xButton.alpha=.7,this.speed2xButton.defaultView.tint=8947848,this.speed4xButton.alpha=1,this.speed4xButton.defaultView.tint=4886754,this.speed12xButton.alpha=.7,this.speed12xButton.defaultView.tint=8947848):t==="12x"&&(this.speed1xButton.alpha=.7,this.speed1xButton.defaultView.tint=8947848,this.speed2xButton.alpha=.7,this.speed2xButton.defaultView.tint=8947848,this.speed4xButton.alpha=.7,this.speed4xButton.defaultView.tint=8947848,this.speed12xButton.alpha=1,this.speed12xButton.defaultView.tint=4886754)}async stopSimulation(){this.isRunning=!1,N(this.gameState);const{MetroBuildingScreen:t}=await A(async()=>{const{MetroBuildingScreen:s}=await import("./index-BUSpScVp.js").then(i=>i.aG);return{MetroBuildingScreen:s}},[]),{engine:n}=await A(async()=>{const{engine:s}=await import("./index-BUSpScVp.js").then(i=>i.aF);return{engine:s}},[]);await n().navigation.showScreen(t);const e=n().navigation.currentScreen;e&&e.setGameState&&e.setGameState(this.gameState)}updateSimulation=t=>{if(!this.isRunning)return;const n=performance.now(),e=(n-this.lastUpdateTime)/1e3;this.lastUpdateTime=n;let s,i;switch(this.currentSpeed){case"1x":s=K,i=1;break;case"2x":s=j,i=2;break;case"4x":s=J,i=4;break;case"12x":s=Q,i=12;break}const r=e*s;this.gameState.simulationTime+=r;const c=new Date(this.gameState.simulationTime);this.clockLabel.text=this.formatDateTime(c),this.updateTrains(e*i),this.drawTrains()};startSimulation(){this.isRunning=!0,this.lastUpdateTime=performance.now(),this.initializeTrains(),this.setSpeed(this.currentSpeed)}initializeTrains(){for(const t of this.gameState.lines)if(!t.trains||t.trains.length===0){t.trains=[];const n=W(t.id,0,1);this.updateTrainPath(n,t),t.trains.push(n)}else for(const n of t.trains)n.currentSegment||this.updateTrainPath(n,t)}updateTrains(t){for(const n of this.gameState.lines)if(n.trains)for(const e of n.trains){if(!e.currentSegment&&(this.updateTrainPath(e,n),!e.currentSegment))continue;const i=e.speed*t/e.totalLength;e.progress+=i,e.progress>=1&&(e.currentStationIdx=e.targetStationIdx,e.progress=0,n.isLoop?e.direction===1?e.targetStationIdx=(e.currentStationIdx+1)%n.stationIds.length:e.targetStationIdx=(e.currentStationIdx-1+n.stationIds.length)%n.stationIds.length:e.direction===1?e.currentStationIdx>=n.stationIds.length-1?(e.direction=-1,e.targetStationIdx=e.currentStationIdx-1):e.targetStationIdx=e.currentStationIdx+1:e.currentStationIdx<=0?(e.direction=1,e.targetStationIdx=e.currentStationIdx+1):e.targetStationIdx=e.currentStationIdx-1,this.updateTrainPath(e,n))}}updateTrainPath(t,n){const e=t.currentStationIdx,s=t.targetStationIdx,i=n.stationIds[e],r=n.stationIds[s],c=this.gameState.stations.find(x=>x.id===i),o=this.gameState.stations.find(x=>x.id===r);if(!c||!o)return;if(c.id===o.id){t.currentSegment={fromStation:c,toStation:o,entryAngle:v.EAST,exitAngle:v.EAST,waypoints:[{x:c.vertexX,y:c.vertexY,type:"STATION"}]},t.totalLength=0;return}const h=Math.min(e,s),a=Math.max(e,s),l=n.stationIds[h],p=n.stationIds[a],f=this.gameState.stations.find(x=>x.id===l),m=this.gameState.stations.find(x=>x.id===p);let S=null;if(a+1<n.stationIds.length){const x=n.stationIds[a+1],y=this.gameState.stations.find(g=>g.id===x);y&&(S=O(m,y))}const d=R(f,m,S);e>s&&d.waypoints.reverse(),t.currentSegment=d,t.totalLength=this.calculateSegmentLength(d)}calculateSegmentLength(t){let n=0;const e=t.waypoints;for(let s=0;s<e.length-1;s++){const i=e[s],r=e[s+1],c=r.x-i.x,o=r.y-i.y;n+=Math.sqrt(c*c+o*o)}return n}drawTrains(){this.trainsLayer.clear();const t=this.buildSegmentSharingMap();for(const n of this.gameState.lines){if(!n.trains)continue;const e=_[n.color],s=this.gameState.lines.indexOf(n);for(const i of n.trains){if(!i.currentSegment)continue;const r=this.getTrainPosition(i,s,t);if(!r)continue;const c=Z,o=Math.cos(r.angle),h=Math.sin(r.angle),a=-8.25,l=5.25,p=8.25,f=c/2,S=[{x:a,y:-f},{x:l,y:-f},{x:p,y:0},{x:l,y:f},{x:a,y:f}].map(d=>({x:r.x+(d.x*o-d.y*h),y:r.y+(d.x*h+d.y*o)}));this.trainsLayer.poly(S.flatMap(d=>[d.x,d.y])),this.trainsLayer.fill(e),this.trainsLayer.stroke({width:1,color:0})}}}getTrainPosition(t,n,e){if(!t.currentSegment)return null;const s=t.totalLength*t.progress;let i=0;const r=t.currentSegment.waypoints,c=M(t.currentSegment.fromStation.id,t.currentSegment.toStation.id),o=e.get(c);let h=0,a=0;if(o&&o.lineIndices.length>1){const p=o.lineIndices.length,f=o.lineIndices.indexOf(n),m=(p-1)/2,d=(f-m)*Y/u;if(o.orientation==="HORIZONTAL")a=d;else if(o.orientation==="VERTICAL")h=d;else{const x=t.currentSegment.toStation.vertexX-t.currentSegment.fromStation.vertexX,y=t.currentSegment.toStation.vertexY-t.currentSegment.fromStation.vertexY,g=Math.sqrt(x*x+y*y);g>0&&(h=-y/g*d,a=x/g*d)}}for(let p=0;p<r.length-1;p++){const f=r[p],m=r[p+1],S=f.x+h,d=f.y+a,x=m.x+h,y=m.y+a,g=Math.sqrt(Math.pow(x-S,2)+Math.pow(y-d,2));if(i+g>=s){const L=(s-i)/g,I=S+(x-S)*L,T=d+(y-d)*L,B=Math.atan2(y-d,x-S);return{x:I*u,y:T*u,angle:B}}i+=g}const l=r[r.length-1];return{x:(l.x+h)*u,y:(l.y+a)*u,angle:0}}setGameState(t){this.gameState=t,(!this.gameState.simulationTime||isNaN(this.gameState.simulationTime))&&(this.gameState.simulationTime=new Date("2025-01-01T08:00:00").getTime()),this.mapRenderer.renderMap(t.map),this.drawMapBackground(),this.drawStations(),this.drawLines();const n=new Date(this.gameState.simulationTime);this.clockLabel.text=this.formatDateTime(n)}drawMapBackground(){const t=this.gameState.map.width*u,n=this.gameState.map.height*u;this.mapBackground.clear(),this.mapBackground.rect(0,0,t,n),this.mapBackground.stroke({width:2,color:4473924})}drawStations(){this.stationsLayer.clear();for(const t of this.gameState.stations){const n=t.vertexX*u,e=t.vertexY*u;this.stationsLayer.circle(n,e,P),this.stationsLayer.fill(G),this.stationsLayer.circle(n,e,P),this.stationsLayer.stroke({width:U,color:$})}}buildSegmentSharingMap(){const t=new Map;return this.gameState.lines.forEach((n,e)=>{for(let s=0;s<n.stationIds.length-1;s++){const i=n.stationIds[s],r=n.stationIds[s+1],c=M(i,r);if(!t.has(c)){const o=this.gameState.stations.find(l=>l.id===i),h=this.gameState.stations.find(l=>l.id===r);let a="HORIZONTAL";if(o&&h){const l=h.vertexX-o.vertexX,p=h.vertexY-o.vertexY;a=F(l,p)}t.set(c,{lineIndices:[],orientation:a})}t.get(c).lineIndices.push(e)}}),t}drawLines(){this.linesLayer.clear();const t=this.buildSegmentSharingMap();this.gameState.lines.forEach((n,e)=>{this.drawLine(n,e,t)})}drawLine(t,n,e){if(t.stationIds.length<2)return;const s=_[t.color],i=t.stationIds.map(o=>this.gameState.stations.find(h=>h.id===o)).filter(o=>o!==void 0);if(i.length<2)return;const r=[],c=[];for(let o=0;o<i.length-1;o++){const h=i[o],a=i[o+1];let l=null;if(o<i.length-2){const x=i[o+2];l=O(a,x)}const p=R(h,a,l);r.push(p);const f=M(h.id,a.id),m=e.get(f);let S=0,d=0;if(m&&m.lineIndices.length>1){const x=m.lineIndices.length,y=m.lineIndices.indexOf(n),g=(x-1)/2,L=y-g,I=a.vertexX-h.vertexX,T=a.vertexY-h.vertexY,B=L*Y/u;if(m.orientation==="HORIZONTAL")d=B;else if(m.orientation==="VERTICAL")S=B;else{const D=Math.sqrt(I*I+T*T);D>0&&(S=-T/D*B,d=I/D*B)}}c.push({offsetX:S,offsetY:d})}this.renderSegmentsToCanvas(r,c,s)}renderSegmentsToCanvas(t,n,e){if(t.length===0)return;const s=q,i=s*2,r=.5,c=n[0]||{offsetX:0,offsetY:0};this.linesLayer.moveTo((t[0].waypoints[0].x+c.offsetX)*u,(t[0].waypoints[0].y+c.offsetY)*u);for(let o=0;o<t.length;o++){const h=t[o],a=n[o]||{offsetX:0,offsetY:0},l=h.waypoints;for(let p=0;p<l.length-1;p++){const f=l[p+1],m=(f.x+a.offsetX)*u,S=(f.y+a.offsetY)*u;if(f.type==="BEND"){const d=f,x=d.incomingAngle??v.EAST,y=d.outgoingAngle??v.EAST,g=this.createBendCurve(d,x,y,i,r);this.linesLayer.lineTo((g.start.x+a.offsetX)*u,(g.start.y+a.offsetY)*u),this.linesLayer.bezierCurveTo((g.control1.x+a.offsetX)*u,(g.control1.y+a.offsetY)*u,(g.control2.x+a.offsetX)*u,(g.control2.y+a.offsetY)*u,(g.end.x+a.offsetX)*u,(g.end.y+a.offsetY)*u)}else this.linesLayer.lineTo(m,S)}}this.linesLayer.stroke({width:s,color:e})}createBendCurve(t,n,e,s,i){const r=s/u,c=X[n],o={x:t.x-r*c.dx,y:t.y-r*c.dy},h=X[e],a={x:t.x+r*h.dx,y:t.y+r*h.dy},l=r*i,p={x:o.x+l*c.dx,y:o.y+l*c.dy},f={x:a.x-l*h.dx,y:a.y-l*h.dy};return{start:o,control1:p,control2:f,end:a}}resize(t,n){const e=t*.5;this.titleLabel.x=150,this.titleLabel.y=30,this.clockLabel.x=t-250,this.clockLabel.y=35;const s=n-80;this.stopButton.x=e-280,this.stopButton.y=s,this.speed1xButton.x=e+100,this.speed1xButton.y=s,this.speed2xButton.x=e+170,this.speed2xButton.y=s,this.speed4xButton.x=e+240,this.speed4xButton.y=s,this.speed12xButton.x=e+310,this.speed12xButton.y=s;const i=this.mapRenderer.getMapWidth(),r=this.mapRenderer.getMapHeight(),c=90,o=n-c-120,a=(t-40)/i,l=o/r,p=Math.min(1,a,l);this.mapContainer.scale.set(p),this.mapContainer.x=e-i*p/2,this.mapContainer.y=c}async show(){const t=[this.titleLabel,this.clockLabel,this.stopButton,this.speed1xButton,this.speed2xButton,this.speed4xButton,this.speed12xButton,this.mapContainer];for(const n of t)n.alpha=0;await z(t,{alpha:[0,1]},{duration:.3}).finished}update(){this.updateSimulation(H.shared)}onDestroy(){this.isRunning=!1}}export{et as MetroSimulationScreen};
